use clap::{arg, command, Command, value_parser};

mod get_km_paths;
use get_km_paths::get_km_paths;

mod index_kmers;
use index_kmers::index_kmers;

mod get_headers;
use get_headers::get_headers;

mod to_reads;
use to_reads::to_reads;

mod validate_kmers;
use validate_kmers::validate_kmers;


///////////////////////// CONSTANTS /////////////////////////
/// Constant for the findere approach: z
const Z: usize = 0;

///////////////////////// MAIN /////////////////////////

fn main() {
    let matches = command!() // requires `cargo` feature
        .propagate_version(true)
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(
            Command::new("index_kmers")
            .arg(
                arg!([KMINDEX_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmindex_path")
                    .help("Path to kmindex binary if not in the PATH")
            )
            .arg(
                arg!([KMTRICKS_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmtricks_path")
                    .help("Path to kmtricks binary if not in the PATH")
            )
            .arg(
                arg!([IN_KMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmers")
                    .required(true)
                    .help("Input fasta file containing the kmers")
            )
            .arg(
                arg!([OUT_INDEX])
                    .value_parser(value_parser!(String))
                    .long("out_index")
                    .required(true)
                    .help("Indexed kmers, using kmindex")
            )
            .arg(
                arg!([K])
                    .value_parser(value_parser!(usize))
                    .short('k')
                    .default_value("31")
                    .help("kmer size")
            )
            .arg(
                arg!([T])
                    .value_parser(value_parser!(usize))
                    .short('t')
                    .default_value("8")
                    .help("kmindex number of threads")
            )
            .arg(
                arg!([BLOOMSIZE])
                    .value_parser(value_parser!(u64))
                    .long("bloom_size")
                    .default_value("10000000")
                    .help("size of the bloom filter in bits")
            )
            .about("Index kmers")
        )

        .subcommand(
            Command::new("query_sequences") // both get_headers and query_sequences together
            .arg(
                arg!([HEADERS])
                    .value_parser(value_parser!(String))
                    .long("tmp_headers")
                    .required(false)
                    .default_value("tmp_headers")
                    .help("File containing the filtered headers, generated by kmindex")
            )
            .arg(
                arg!([KMINDEX_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmindex_path")
                    .help("Path to kmindex binary if not in the PATH")
            )
            .arg(
                arg!([KMTRICKS_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmtricks_path")
                    .help("Path to kmtricks binary if not in the PATH")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_sequences")
                    .required(true)
                    .help("Input fasta file containing the original sequences in which we search the kmers")
            )
            .arg(
                arg!([INKMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmer_index")
                    .required(true)
                    .help("Directeroy name containing the indexed kmers, using kmindex (obtained with index_kmers --out_index)")
            )
            .arg(
                arg!([OUTFASTA])
                    .value_parser(value_parser!(String))
                    .long("out_fasta")
                    .required(true)
                    .help("Output fasta file containing the retreived sequences")
            )
            .arg(
                arg!([THRESHOLD])
                    .value_parser(value_parser!(f32))
                    .long("threshold")
                    .default_value("0.0")
                    .help("Conserve only sequences with **ratio** bigger than this value")
            )
            .arg(
                arg!([T])
                    .value_parser(value_parser!(usize))
                    .short('t')
                    .default_value("8")
                    .help("kmindex number of threads")
            )
            .about("Query sequences on indexed kmers and output filtered fasta. Cumulates the \"get_headers\" and \"to_reads\" subcommands")
        )

        .subcommand(
            Command::new("query_sequences_get_headers")
            .arg(
                arg!([KMINDEX_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmindex_path")
                    .help("Path to kmindex binary if not in the PATH")
            )
            .arg(
                arg!([KMTRICKS_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmtricks_path")
                    .help("Path to kmtricks binary if not in the PATH")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_sequences")
                    .required(true)
                    .help("Input fasta file containing the original sequences in which we search the kmers")
            )
            .arg(
                arg!([INKMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmer_index")
                    .required(true)
                    .help("Directeroy name containing the indexed kmers, using kmindex (obtained with index_kmers --out_index)")
            )
            .arg(
                arg!([HEADERS])
                    .value_parser(value_parser!(String))
                    .short('o').long("out_headers")
                    .required(true)
                    .help("The output directory that will contain the headers of the sequences that contain kmers in the indexed kmers")
            )
            .arg(
                arg!([T])
                    .value_parser(value_parser!(usize))
                    .short('t')
                    .default_value("8")
                    .help("kmindex number of threads")
            )
            .about("Query sequences on indexed kmers and output selected headers")
        )

        .subcommand(
            Command::new("query_sequences_to_reads")
            .arg(
                arg!([HEADERS])
                    .value_parser(value_parser!(String))
                    .long("in_headers")
                    .required(true)
                    .help("File containing the filtered headers, generated by kmindex")
            )
            .arg(
                arg!([INKMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmer_index")
                    .required(true)
                    .help("Directeroy name containing the indexed kmers, using kmindex (obtained with index_kmers --out_index)")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_fasta")
                    .required(true)
                    .help("Input fasta file containing the original sequences")
            )
            .arg(
                arg!([OUTFASTA])
                    .value_parser(value_parser!(String))
                    .long("out_fasta")
                    .required(true)
                    .help("Output fasta file containing the retreived sequences")
            )
            .arg(
                arg!([THRESHOLD])
                    .value_parser(value_parser!(f32))
                    .default_value("0.0")
                    .long("threshold")
                    .help("Conserve only sequences with **ratio** bigger than this value")
                )
            .about("From selected headers to reads")
        )
        .subcommand(
            Command::new("exact_count")
            .arg(
                arg!([IN_KMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmers")
                    .required(true)
                    .help("Input fasta file containing the original kmers")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_fasta")
                    .required(true)
                    .help("Input fasta file containing the already filtered sequences")
            )
            .arg(
                arg!([OUTFASTA])
                    .value_parser(value_parser!(String))
                    .long("out_fasta")
                    .required(true)
                    .help("Output fasta file containing the filtered sequences, adding their exact count")
            )
            .arg(
                arg!([OUTKMERS])
                    .value_parser(value_parser!(String))
                    .long("out_counted_kmers")
                    .required(false)
                    .default_value("")
                    .help("If specified, Output a text file containing each (canonical) kmer found at least once in the read, with their number of occurrences in the reads. Exact values.")
            )
            .about("From filtered reads, find their exact number of shared kmers with the original kmers.")
        )
        .get_matches();
    
    match matches.subcommand() {
        Some(("index_kmers", sub_matches)) => {
            index_kmers(&sub_matches)
        }
        ,
        Some(("query_sequences_get_headers", sub_matches)) => {
            get_headers(&sub_matches)
        }
        ,
        Some(("query_sequences_to_reads", sub_matches)) => {
            to_reads(&sub_matches)
        }
        ,
        Some(("query_sequences", sub_matches)) => {
            get_headers(&sub_matches);  
            to_reads(&sub_matches)      
        }
        ,
        Some(("exact_count", sub_matches)) => {
            let _ = validate_kmers(&sub_matches);      // to finish as INHEADERS is not set
        }
        _ => unreachable!("Exhausted list of subcommands and subcommand_required prevents `None`"),
    }

}
