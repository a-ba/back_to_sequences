use clap::{arg, command, Command, value_parser};

mod get_km_paths;
use get_km_paths::get_km_paths;
mod index_kmers;
use index_kmers::index_kmers;
mod get_headers;
use get_headers::get_headers;
mod to_reads;
use to_reads::to_reads;

///////////////////////// MAIN /////////////////////////

fn main() {
    let matches = command!() // requires `cargo` feature
        .propagate_version(true)
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(
            Command::new("index_kmers")
            .arg(
                arg!([KMINDEX_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmindex_path")
                    .help("Path to kmindex binary if not in the PATH")
            )
            .arg(
                arg!([KMTRICKS_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmtricks_path")
                    .help("Path to kmtricks binary if not in the PATH")
            )
            .arg(
                arg!([IN_KMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmers")
                    .required(true)
                    .help("Input fasta file containing the kmers")
            )
            .arg(
                arg!([OUT_INDEX])
                    .value_parser(value_parser!(String))
                    .long("out_index")
                    .required(true)
                    .help("Indexed kmers, using kmindex")
            )
            .arg(
                arg!([K])
                    .value_parser(value_parser!(u32))
                    .short('k')
                    .default_value("31")
                    .help("kmer size")
            )
            .arg(
                arg!([T])
                    .value_parser(value_parser!(u32))
                    .short('t')
                    .default_value("8")
                    .help("kmindex number of threads")
            )
        )

        .subcommand(
            Command::new("get_headers")
            .arg(
                arg!([KMINDEX_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmindex_path")
                    .help("Path to kmindex binary if not in the PATH")
            )
            .arg(
                arg!([KMTRICKS_PATH])
                    .value_parser(value_parser!(String))
                    .long("kmtricks_path")
                    .help("Path to kmtricks binary if not in the PATH")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_sequences")
                    .required(true)
                    .help("Input fasta file containing the original sequences in which we search the kmers")
            )
            .arg(
                arg!([INKMERS])
                    .value_parser(value_parser!(String))
                    .long("in_kmer_index")
                    .required(true)
                    .help("Directeroy name containing the indexed kmers, using kmindex (obtained with index_kmers --out_index)")
            )
            .arg(
                arg!([OUTHEADERS])
                    .value_parser(value_parser!(String))
                    .short('o').long("out_headers")
                    .required(true)
                    .help("The output directory that will contain the headers of the sequences that contain kmers in the indexed kmers")
            )
            .arg(
                arg!([T])
                    .value_parser(value_parser!(u32))
                    .short('t')
                    .default_value("8")
                    .help("kmindex number of threads")
            )
        )

        .subcommand(
            Command::new("to_reads")
            .arg(
                arg!([INTSVDIR])
                    .value_parser(value_parser!(String))
                    .long("in_tsv_dir")
                    .required(true)
                    .help("File containing the filtered headers, generated by kmindex")
            )
            .arg(
                arg!([INFASTA])
                    .value_parser(value_parser!(String))
                    .long("in_fasta")
                    .required(true)
                    .help("Input fasta file containing the original sequences")
            )
            .arg(
                arg!([OUTFASTA])
                    .value_parser(value_parser!(String))
                    .long("out_fasta")
                    .required(true)
                    .help("Output fasta file containing the retreived sequences")
            )
            .arg(arg!([THRESHOLD])
                .value_parser(value_parser!(f32))
                .default_value("0.0")
                .long("threshold"))
            .about("Do not retreive sequences whose ratio of shared kmers is below or equal to this value")
        )
        .get_matches();

    match matches.subcommand() {
        Some(("index_kmers", sub_matches)) => {
            index_kmers(&sub_matches)
        }
        ,
        Some(("to_reads", sub_matches)) => {
            to_reads(&sub_matches)
        }
        ,
        Some(("get_headers", sub_matches)) => {
            get_headers(&sub_matches)
        }
        _ => unreachable!("Exhausted list of subcommands and subcommand_required prevents `None`"),
    }

}
